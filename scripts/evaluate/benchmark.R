# benchmark.R - functions for processing benchmark data.

# Note:
# 1. Several functions should be imported from `utils.R`:
#    - flush_print, str_now, write_tsv
#    - load_mtx, load_mtx3, load_gene_anno, overlap_gene_anno 
#    - reg2gene, var_reg2gene
# source utils.R


rep_n <- function(v, n) {
  func <- "rep_n"

  m <- length(v)
  if (m < n) {
    if (m != 1)
      stop(sprintf("[E::%s] invalid length of v, 1 expected, %d given.",
                   func, m))
    v <- rep(v, n)
  } else if (m != n)
    stop(sprintf("[E::%s] too long length of v!", func))

  return(v)
}


get_step_index <- function(step_name, step_idx) {
  if (step_name == "roc")
    return(5)
  else if (step_name == "prc")
    return(6)
  else
    stop("[E::get_step_index] invalid step name.")
    #return(step_idx + 1)
}


#' @param sid A string. Sample ID.
#' @param cnv_type A string. CNV type, could be `copy_gain`, `copy_loss`,
#'   or `loh`.
#' @param cnv_scale A string. Region scale, could be `gene` or `arm`.
#' @param dat_list A list of data extracted by calling `run_extract`.
#' @param cell_anno A dataframe containing 2 columns: cell <str>, cell_type
#'   <str> cell type.
#' @param gene_anno A dataframe. It has 4 columns Gene, Chr, start, end. See
#'   `load_gene_anno` for details.
#' @param truth A dataframe containing 5 columns: chrom, start, end, 
#'   cnv_type, and cell_type.
#' @param out_dir A string. Path to output directory.
#' @param overlap_mode A string. Overlap mode, could be `intersect`, `union`,
#'   or `customize`.
#' @param filter_func A function to filter cells or genes. It should take 2
#'   parameters cells and genes generated by `run_annotate` as input, and 
#'   output filtered cells and genes in a list.
#' @param metrics String vector. Each value could be "ROC" or "PRC".
#' @param max_n_cutoff Integer vector. Maximum number of sampled cutoff values.
#' @param plot_sid A string. Sample ID shown in the figures. Set to `NULL` to
#'   make it the same with `sid`.
#' @param plot_dec Integer vector. Number of decimal places for AUC.
#' @param plot_legend_xmin Float vector. The xmin position of legend.
#' @param plot_legend_ymin Float vector. The ymin position of legend.
#' @param plot_width Float vector. Width of the output figure in units `cm`.
#' @param plot_height Float vector. Height of the output figure in units `cm`.
#' @param plot_dpi Integer vector. DPI of the output figure.
#' @param verbose A bool. Whether to output detailed logging information.
#' @param save_all A bool. Whether to save intermediate results into files.
#' @return ggplot2 object vector. 
run_benchmark <- function(
  sid, cnv_type, cnv_scale,
  dat_list, cell_anno, gene_anno, truth, out_dir,
  overlap_mode = "customize", filter_func = NULL, 
  metrics = c("ROC", "PRC"), max_n_cutoff = 1000,
  plot_sid = NULL,
  plot_dec = 3, plot_legend_xmin = 0.7, plot_legend_ymin = 0.25,
  plot_width = 6.5, plot_height = 5, plot_dpi = 600,
  verbose = FALSE, save_all = FALSE) 
{
  func <- "run_benchmark"

  n_mt <- length(metrics)
  max_n_cutoff <- rep_n(max_n_cutoff, n_mt)
  if (is.null(plot_sid))
    plot_sid <- sid
  plot_dec <- rep_n(plot_dec, n_mt)
  plot_legend_xmin <- rep_n(plot_legend_xmin, n_mt)
  plot_legend_ymin <- rep_n(plot_legend_ymin, n_mt)
  plot_width <- rep_n(plot_width, n_mt)
  plot_height <- rep_n(plot_height, n_mt)
  plot_dpi <- rep_n(plot_dpi, n_mt)

  prefix <- sprintf("%s.%s.%s_scale", sid, cnv_type, cnv_scale)

  # find overlap cells and genes
  flush_print(sprintf("[I::%s][%s] find overlap cells and genes ...", func, str_now()))

  res_overlap <- run_overlap(dat_list, mode = overlap_mode, verbose = verbose)
  cell_overlap <- res_overlap$cell_overlap
  gene_overlap <- res_overlap$gene_overlap
  dat_list <- res_overlap$dat_list

  if (verbose)
    str(res_overlap)

  dir_overlap <- sprintf("%s/s2_overlap", out_dir)
  save_overlap(res_overlap, dir_overlap, prefix, save_all)
  flush_print(sprintf("[I::%s][%s] overlap data is saved to dir '%s'.", func,
              str_now(), dir_overlap))

  # annotate cells and genes
  flush_print(sprintf("[I::%s][%s] annotate cells and genes ...", func, str_now()))

  cell_annotate <- run_annotate_cell(
    res_overlap$cell_overlap, cell_anno, verbose = verbose)

  if (verbose)
    str(cell_annotate)

  gene_annotate <- run_annotate_gene(
    res_overlap$gene_overlap, gene_anno, verbose = TRUE)

  if (verbose)
    str(gene_annotate)

  dir_annotate <- sprintf("%s/s3_annotate", out_dir)
  save_annotate(cell_annotate, gene_annotate, dir_annotate, prefix, save_all)
  flush_print(sprintf("[I::%s][%s] annotate data is saved to dir '%s'.", func,
              str_now(), dir_annotate))

  # filter cells or genes
  if (is.null(filter_func)) {
    flush_print(sprintf("[I::%s][%s] no filtering ...", func, str_now()))
    
    cell_subset <- cell_annotate$cell_anno_valid
    gene_subset <- gene_annotate$gene_anno_valid
  } 
  else {
    flush_print(sprintf("[I::%s][%s] filter cells or genes ...", 
                func, str_now()))

    res_filter <- filter_func(cell_annotate$cell_anno_valid,
                              gene_annotate$gene_anno_valid)

    if (verbose)
      str(res_filter)
    
    cell_subset <- res_filter$cells
    gene_subset <- res_filter$genes
  }

  # subset data
  flush_print(sprintf("[I::%s][%s] subset data ...", func, str_now()))

  dat_list <- run_subset(cell_subset$cell, gene_subset$Gene, dat_list)

  if (verbose)
    str(dat_list)

  dir_subset <- dir_annotate
  save_subset(cell_subset, gene_subset, dat_list, dir_subset, prefix, save_all)
  flush_print(sprintf("[I::%s][%s] subset data is saved to dir '%s'.", func,
              str_now(), dir_subset))

  # construct the ground truth binary matrix
  flush_print(sprintf("[I::%s][%s] construct the ground truth binary matrix ...",
                      func, str_now()))
  
  res_truth <- run_truth(cell_subset, gene_subset, 
                         truth, cnv_type, verbose = verbose)

  if (verbose)
    str(res_truth)

  dir_truth <- sprintf("%s/s4_truth", out_dir)
  save_truth(res_truth, dir_truth, prefix, save_all)
  flush_print(sprintf("[I::%s][%s] truth data is saved to dir '%s'.", func,
              str_now(), dir_truth))

  # calculate metrics
  flush_print(sprintf("[I::%s][%s] calculate Metrics ...", func, str_now()))

  figs <- list()
  s_idx <- 4
  for (i in 1:n_mt) {
    mt_name <- metrics[i]
    mt_upper <- stringr::str_to_upper(mt_name)
    mt_lower <- stringr::str_to_lower(mt_name)
    flush_print(sprintf("[I::%s][%s] calculate %s ...", func, str_now(),
                         mt_upper))
  
    if (mt_upper == "ROC")
      dat_list <- run_roc(dat_list, res_truth$truth_mtx, 
                          max_n_cutoff = max_n_cutoff[i], 
                          strict = TRUE, verbose = verbose)
    else
      dat_list <- run_prc(dat_list, res_truth$truth_mtx, 
                          max_n_cutoff = max_n_cutoff[i], 
                          strict = TRUE, verbose = verbose)
  
    if (verbose)
      str(dat_list)
  
    s_idx <- get_step_index(mt_lower, s_idx)
    dir_metric <- sprintf("%s/s%d_%s", out_dir, s_idx, mt_lower)
    if (mt_upper == "ROC")
      save_roc(dat_list, dir_metric, prefix, save_all)
    else
      save_prc(dat_list, dir_metric, prefix, save_all)
    flush_print(sprintf("[I::%s][%s] %s data is saved to dir '%s'.", func,
                str_now(), mt_upper, dir_metric))
  
    # visualization
    flush_print(sprintf("[I::%s][%s] visualization ...", func, str_now()))
    p <- p_title <- NULL
  
    if (cnv_type == "copy_gain")
      p_title <- sprintf("%s %s Curve for Copy Gain", plot_sid, mt_upper)
    else if (cnv_type == "copy_loss")
      p_title <- sprintf("%s %s Curve for Copy Loss", plot_sid, mt_upper)
    else
      p_title <- sprintf("%s %s Curve for LOH", plot_sid, mt_upper)
  
    if (mt_upper == "ROC")
      p <- plot_roc(dat_list, dec = plot_dec[i], title = p_title,
                    legend_xmin = plot_legend_xmin[i], 
                    legend_ymin = plot_legend_ymin[i])
    else
      p <- plot_prc(dat_list, dec = plot_dec[i], title = p_title,
                    legend_xmin = plot_legend_xmin[i], 
                    legend_ymin = plot_legend_ymin[i])
  
    dir_plot <- dir_metric
    plot_fn <- sprintf("%s/%s.plot.%s_figure.jpg", dir_plot, prefix, mt_lower)
    ggplot2::ggsave(plot_fn, p, width = plot_width[i], height = plot_height[i],
                    units = "cm", dpi = plot_dpi[i])
    flush_print(sprintf("[I::%s][%s] plot figure is saved to dir '%s'.", func,
                str_now(), dir_plot))
    figs[[i]] <- p
  }

  return(figs)
}


#' Fast Version of Benchmarking
#' Run fast version of benchmarking if overlap cells and genes are given.
#' @inheritParams run_benchmark
#' @param xclone_mtx A cell x gene matrix.
#' @param metrics String vector. Each value could be "ROC" or "PRC".
#' @param metric_fn String vector. Path to file containing a list of metric 
#'   data generated by `run_roc` or `run_prc`.
#' @param cell_subset_fn A string. Path to file containing subset cells 
#'   returned by `run_subset`.
#' @param gene_subset_fn A string. Path to file containing subset genes 
#'   returned by `run_subset`.
#' @param truth_fn A string. Path to file containing ground truth matrix
#'   returned by `run_truth`.
#' @return ggplot2 object vector.
run_bm_fast <- function(
  sid, cnv_type, cnv_scale,
  xclone_mtx, metrics, metric_fn,
  cell_subset_fn, gene_subset_fn, truth_fn, out_dir,
  max_n_cutoff = 1000,
  plot_sid = NULL,
  plot_dec = 3, plot_legend_xmin = 0.7, plot_legend_ymin = 0.25,
  plot_width = 6.5, plot_height = 5, plot_dpi = 600,
  verbose = FALSE, save_all = FALSE) 
{
  func <- "run_bm_fast"

  n_mt <- length(metrics)
  max_n_cutoff <- rep_n(max_n_cutoff, n_mt)
  if (is.null(plot_sid))
    plot_sid <- sid
  plot_dec <- rep_n(plot_dec, n_mt)
  plot_legend_xmin <- rep_n(plot_legend_xmin, n_mt)
  plot_legend_ymin <- rep_n(plot_legend_ymin, n_mt)
  plot_width <- rep_n(plot_width, n_mt)
  plot_height <- rep_n(plot_height, n_mt)
  plot_dpi <- rep_n(plot_dpi, n_mt)
  
  prefix <- sprintf("%s.%s.%s_scale", sid, cnv_type, cnv_scale)

  if (! dir.exists(out_dir))
    dir.create(out_dir, recursive = TRUE)

  # load data
  flush_print(sprintf("[I::%s][%s] load data ...", func, str_now()))
  
  cell_subset <- read.delim(cell_subset_fn, header = T, stringsAsFactors = F)
  gene_subset <- read.delim(gene_subset_fn, header = T, stringsAsFactors = F)
  truth <- readRDS(truth_fn)

  flush_print(sprintf("[I::%s][%s] the binary truth matrix is ...", 
                      func, str_now()))
  str(truth)

  dir_input <- NULL
  if (save_all) {
    dir_input <- sprintf("%s/input", out_dir)
    if (! dir.exists(dir_input))
      dir.create(dir_input, recursive = TRUE)
    write_tsv(cell_subset, 
              sprintf("%s/%s.input.cell_subset.df.tsv", dir_input, prefix))
    write_tsv(gene_subset, 
              sprintf("%s/%s.input.gene_subset.df.tsv", dir_input, prefix))
    saveRDS(truth, 
            sprintf("%s/%s.input.binary_truth.mtx.rds", dir_input, prefix))
    flush_print(sprintf("[I::%s][%s] input data is saved to dir '%s'.", func,
                str_now(), dir_input))
  }

  if (length(cell_subset$cell) != nrow(truth))
    stop(sprintf(
      "[E::%s] number of subset cells and truth cells are different!", func))
  if (! all(sort(cell_subset$cell) == sort(rownames(truth))))
    stop(sprintf(
      "[E::%s] subset cells and truth cells are different!", func))
  
  if (length(gene_subset$Gene) != ncol(truth))
    stop(sprintf(
      "[E::%s] number of subset genes and truth genes are different!", func))
  if (! all(sort(gene_subset$Gene) == sort(colnames(truth))))
    stop(sprintf(
      "[E::%s] subset genes and truth genes are different!", func))

  # subset xclone matrix
  flush_print(sprintf("[I::%s][%s] subset xclone matrix ...", func, str_now()))
  
  if (! all(cell_subset$cell %in% rownames(xclone_mtx)))
    stop(sprintf("[E::%s] some subset cells are not in xclone matrix!", func))

  if (! all(gene_subset$Gene %in% colnames(xclone_mtx)))
    stop(sprintf("[E::%s] some subset genes are not in xclone matrix!", func))

  xclone_mtx <- xclone_mtx[cell_subset$cell, gene_subset$Gene]

  if (verbose)
    str(xclone_mtx)

  # calculate metrics
  figs <- list()
  s_idx <- 4
  for (i in 1:n_mt) {
    mt_name <- metrics[i]
    mt_upper <- stringr::str_to_upper(mt_name)
    mt_lower <- stringr::str_to_lower(mt_name)

    dat_list <- readRDS(metric_fn[i])
    if (save_all) {
      saveRDS(dat_list, 
              sprintf("%s/%s.input.%s_list.list.rds", dir_input, prefix,
                      mt_lower))
    }
    flush_print(sprintf("[I::%s][%s] calculate xclone %s ...", func, str_now(),
                         mt_upper))
  
    xclone_dat_list <- list(list(
      sid = sid, cnv_type = cnv_type,
      method = "xclone", method_sub = "xclone", mtx_type = "prob",
      cnv_scale = cnv_scale, mtx = xclone_mtx, overlap = NULL
    ))
  
    if (mt_upper == "ROC")
      xclone_dat_list <- run_roc(xclone_dat_list, truth, 
                                 max_n_cutoff = max_n_cutoff[i], 
                                 strict = TRUE, verbose = verbose)
    else
      xclone_dat_list <- run_prc(xclone_dat_list, truth, 
                                 max_n_cutoff = max_n_cutoff[i], 
                                 strict = TRUE, verbose = verbose)
    
    if (verbose)
      str(xclone_dat_list)
  
    # merge metric data
    flush_print(sprintf("[I::%s][%s] merge %s data ...", func, str_now(),
                        mt_upper))
  
    xclone_dat <- xclone_dat_list[[1]]
  
    j <- 1
    for (dat in dat_list) {
      if (dat$method == "xclone") {
        dat_list[[j]] <- xclone_dat
        break
      }
      j <- j + 1
    }
    if (j > length(dat_list))
      dat_list[[j]] <- xclone_dat
  
    if (verbose)
      str(dat_list)

    s_idx <- get_step_index(mt_lower, s_idx)
    dir_metric <- sprintf("%s/s%d_%s", out_dir, s_idx, mt_lower)
    if (mt_upper == "ROC") 
      save_roc(dat_list, dir_metric, prefix, save_all)
    else
      save_prc(dat_list, dir_metric, prefix, save_all)
    flush_print(sprintf("[I::%s][%s] updated %s data is saved to dir '%s'.", 
                func, str_now(), mt_lower, dir_metric))
  
    # visualization
    flush_print(sprintf("[I::%s][%s] visualization ...", func, str_now()))
  
    if (cnv_type == "copy_gain")
      p_title <- sprintf("%s %s Curve for Copy Gain", plot_sid, mt_upper)
    else if (cnv_type == "copy_loss")
      p_title <- sprintf("%s %s Curve for Copy Loss", plot_sid, mt_upper)
    else
      p_title <- sprintf("%s %s Curve for LOH", plot_sid, mt_upper)
  
    if (mt_upper == "ROC")
      p <- plot_roc(dat_list, dec = plot_dec[i], title = p_title,
                    legend_xmin = plot_legend_xmin[i], 
                    legend_ymin = plot_legend_ymin[i])
    else
      p <- plot_prc(dat_list, dec = plot_dec[i], title = p_title,
                    legend_xmin = plot_legend_xmin[i], 
                    legend_ymin = plot_legend_ymin[i])
  
    dir_plot <- dir_metric
    plot_fn <- sprintf("%s/%s.plot.%s_figure.jpg", dir_plot, prefix, mt_lower)
    ggplot2::ggsave(plot_fn, p, width = plot_width[i], height = plot_height[i],
                    units = "cm", dpi = plot_dpi[i])
    flush_print(sprintf("[I::%s][%s] plot figure is saved to dir '%s'.", func,
                str_now(), dir_plot))
    figs[[i]] <- p
  }

  return(figs)
}


#' Extract CNV Data from CaSpER Output
#' @param sid A string. Sample ID.
#' @param dat_dir A string. Path to data dir.
#' @param cnv_type A string. CNV type, could be `copy_gain`, `copy_loss`,
#'   or `loh`.
#' @param method_sub A string. Specific sub-type method.
#' @param mtx_type A string. Type of returned matrix, could be 
#'   "baf" for BAF, "expr" for expression or "prob" for probability.
#' @param cnv_scale A string. Region scale, could be `gene` or `arm`.
#' @param gene_anno A dataframe. It has 4 columns Gene, Chr, start, end. See
#'   `load_gene_anno` for details.
#' @return A list of 2 elements: 1) mtx: cell x gene matrix; 2) overlap: NULL
#'   if method_sub is "casper", otherwise a data frame storing the overlapping
#'   results of all input genes, it contains 4 columns: 2.1) Gene <string> 
#'   gene name; 2.2) cell <chr> cell barcodes; 2.3) reg_id <string> region ID;
#'   2.4) score <num> interested values.
extract_casper <- function(
  sid, dat_dir, cnv_type, method_sub = "casper", mtx_type = "expr",
  cnv_scale = "gene", gene_anno = NULL) 
{
  if (method_sub == "casper") {
    obj_fn <- sprintf("%s/%s.object.rds", dat_dir, sid)
    obj <- readRDS(obj_fn)
    mtx <- log2(obj@control.normalized.noiseRemoved[[3]])
    mtx <- t(mtx)   # cell x gene matrix
    dat <- list(mtx = mtx, overlap = NULL)
    return(dat)
  } else if (method_sub %in% c("casper_median", "casper_mediandev")) {
    # TODO: 0119 update!!
    obj_fn <- sprintf("%s/%s.object.scale.rds", dat_dir, sid)
    obj <- readRDS(obj_fn)
    df <- obj@segments
    df <- df %>%
      dplyr::select(ID, chr, start, end, state, median, medianDev) %>%
      dplyr::mutate(cell = ID) %>%
      dplyr::mutate(chrom = gsub("[pq]", "", chr)) %>%
      dplyr::mutate(chrom = gsub("chr", "", chrom))
    if (method_sub == "casper_median") {
      df <- df %>%
        dplyr::select(cell, chrom, start, end, state, median) %>%
        dplyr::rename(score = median)
      df$score[df$state != "3" & df$state != 3] <- min(df$score) - 0.1  # CHECK ME!
    } else {  # method_sub == "casper_mediandev"
      df <- df %>%
        dplyr::mutate(medianDev = as.numeric(medianDev)) %>%
        dplyr::select(cell, chrom, start, end, state, medianDev) %>%
        dplyr::rename(score = medianDev)
      df$score[df$state != "3" & df$state != 3] <- 0   # CHECK ME!
    } 
    dat <- var_reg2gene(df, gene_anno)
    return(dat)
  } else {
    stop(sprintf("[E::%s] unknown sub-type method '%s'.", func, method_sub))
  }
}


#' Extract CNV Data from CopyKAT Output
#' @inheritParams extract_casper
#' @return A list of 2 elements: 1) mtx: cell x gene matrix; 2) overlap: NULL
extract_copykat <- function(
  sid, dat_dir, cnv_type, method_sub = "copykat", mtx_type = "expr",
  cnv_scale = "gene", gene_anno = NULL) 
{
  obj_fn <- sprintf("%s/%s_copykat_CNA_raw_results_gene_by_cell.txt", 
                    dat_dir, sid)
  mtx <- read.delim(obj_fn, header = T, check.names = F, stringsAsFactors = F)
  rownames(mtx) <- mtx$hgnc_symbol
  mtx <- mtx[, -(1:7)]
  mtx <- t(mtx)    # cell x gene matrix
  dat <- list(mtx = mtx, overlap = NULL)
  return(dat)
}


#' Extract CNV Data from inferCNV Output
#' @inheritParams extract_casper
#' @return A list of 2 elements: 1) mtx: cell x gene matrix; 2) overlap: NULL
extract_infercnv <- function(
  sid, dat_dir, cnv_type, method_sub = "infercnv", mtx_type = "expr",
  cnv_scale = "gene", gene_anno = NULL) 
{
  obj_fn <- sprintf(
    "%s/BayesNetOutput.HMMi6.hmm_mode-samples/MCMC_inferCNV_obj.rds", dat_dir)
  obj <- readRDS(obj_fn)
  mtx <- obj@expr.data
  mtx <- t(mtx)    # cell x gene matrix
  dat <- list(mtx = mtx, overlap = NULL)
  return(dat)
}


#' Extract CNV Data from Numbat Output
#' @inheritParams extract_casper
#' @return A list of 2 elements: 1) mtx, a cell x gene matrix
#'   containing only the genes overlapping with one region; 2) overlap, a
#'   data frame storing the overlapping results of all input genes.
extract_numbat <- function(
  sid, dat_dir, cnv_type, method_sub = "numbat", mtx_type = "expr",
  cnv_scale = "gene", gene_anno = NULL)
{
  obj_fn <- sprintf("%s/joint_post_2.tsv", dat_dir)
  mtx <- read.delim(obj_fn, header = T, check.names = F, stringsAsFactors = F)
  mtx <- mtx %>%
    dplyr::select(cell, CHROM, seg_start, seg_end, 
                  p_amp, p_del, p_loh, p_bamp, p_bdel) %>%
    dplyr::mutate(p_amp = p_amp + p_bamp) %>%
    dplyr::mutate(p_del = p_del + p_bdel) %>%
    dplyr::mutate(chrom = gsub("chr", "", CHROM)) %>%
    dplyr::mutate(reg_id = sprintf("%s:%s-%s", chrom, seg_start, seg_end))
  if (cnv_type == "copy_gain")
    mtx <- mtx %>%
      dplyr::select(cell, reg_id, p_amp) %>%
      tidyr::spread(reg_id, p_amp)
  else if (cnv_type == "copy_loss")
    mtx <- mtx %>%
      dplyr::select(cell, reg_id, p_del) %>%
      tidyr::spread(reg_id, p_del)
  else if (cnv_type == "loh")
    mtx <- mtx %>%
      dplyr::select(cell, reg_id, p_loh) %>%
      tidyr::spread(reg_id, p_loh)
  else
    stop(sprintf("Error: unknown cnv type '%s'.", cnv_type))
  cells <- mtx$cell
  mtx <- as.matrix(mtx[, -1])
  rownames(mtx) <- cells
  dat <- reg2gene(mtx, gene_anno)  # cell x gene matrix
  return(dat)
}


#' Load CNV Data from XClone Output
#' @inheritParams extract_casper
#' @return A list of 2 elements: 1) mtx, a cell x gene matrix
#'   containing only the genes overlapping with one region; 2) overlap, a
#'   data frame storing the overlapping results of all input genes.
extract_xclone <- function(
  sid, dat_dir, cnv_type, method_sub = "xclone", mtx_type = "expr",
  cnv_scale = "gene", gene_anno = NULL) 
{
  if (cnv_scale == "arm") {
    mtx <- load_mtx3(sprintf("%s/cells.csv", dat_dir),
                     sprintf("%s/Features.csv", dat_dir),
                     sprintf("%s/matrix.csv", dat_dir))   # cell x arm matrix
    dat <- reg2gene(mtx, gene_anno)     # cell x gene matrix
  } else {
    mtx <- load_mtx(sprintf("%s/cells.csv", dat_dir),
                    sprintf("%s/Features.csv", dat_dir),
                    sprintf("%s/matrix.csv", dat_dir))    # cell x gene matrix
    dat <- list(mtx = mtx, overlap = NULL)
  }
  return(dat)
}


#' Load CNV Data from Output of All Methods
#' @inheritParams extract_casper
#' @param method_list A string vector. Names of methods.
#' @param method_sub_list A string vector. Names of sub-type methods.
#' @param mtx_type_list A string vector. Matrix type could be "baf", 
#'   "expr" or "prob".
#' @param dat_dir_list A string vector. Data dir of each method.
#' @param verbose A bool. Whether to output detailed information.
#' @return A list containing extracted data for specific method and mtx_type.
#'   Each element in the list is also a list of 7 elements:
#'   `sid` <str>; `cnv_type` <str>; `method`` <str>; `mtx_type` <str>; 
#'   `cnv_scale` <str>; `mtx` <matrix> cell x gene matrix; 
#'   `overlap` <data.frame>;
#' 
#' @section Note:
#' `method_list`, `method_sub_list`, `mtx_type_list` and `dat_dir_list` 
#' should have the same length.
#' 
#' @examples
#' gene_anno <- load_gene_anno(fn)
#' dat_list <- run_extract(
#'   sid = "Test007", cnv_type = "copy_gain", cnv_scale = "gene",
#'   gene_anno = gene_anno,
#'   method_list = c("casper", "numbat", "xclone", "xclone"),
#'   method_sub_list = c("casper", "numbat", "xclone", "xclone"),
#'   mtx_type_list = c("expr", "prob", "expr", "prob"),
#'   dat_dir_list = c(
#'     "./casper_out", "./numbat_out", "./xclone_out", "./xclone_out")
#' )
#' print(dat_list)
run_extract <- function(
  sid, cnv_type, cnv_scale, gene_anno,
  method_list, method_sub_list, mtx_type_list, dat_dir_list,
  verbose = FALSE) 
{
  func <- "run_extract"

  if (verbose)
    flush_print(sprintf("[I::%s] sid = %s; cnv_type = %s; cnv_scale = %s.",
                   func, sid, cnv_type, cnv_scale))

  res <- list()
  n <- length(method_list)
  for (i in 1:n) {
    method <- stringr::str_to_lower(method_list[i])
    method_sub <- stringr::str_to_lower(method_sub_list[i])
    mtx_type <- stringr::str_to_lower(mtx_type_list[i])
    dat_dir <- dat_dir_list[i]
    if (verbose)
      flush_print(
        sprintf("[I::%s] processing method_sub = %s; mtx_type = %s ...", 
                func, method_sub, mtx_type))

    if (method == "casper") {
      rdat <- extract_casper(sid, dat_dir, cnv_type, method_sub, mtx_type, 
                             cnv_scale, gene_anno)
    } else if (method == "copykat") {
      rdat <- extract_copykat(sid, dat_dir, cnv_type, method_sub, mtx_type, 
                              cnv_scale, gene_anno)
    } else if (method == "infercnv") {
      rdat <- extract_infercnv(sid, dat_dir, cnv_type, method_sub, mtx_type, 
                               cnv_scale, gene_anno)
    } else if (method == "numbat") {
      rdat <- extract_numbat(sid, dat_dir, cnv_type, method_sub, mtx_type, 
                             cnv_scale, gene_anno)
    } else if (method == "xclone") {
      rdat <- extract_xclone(sid, dat_dir, cnv_type, method_sub, mtx_type, 
                             cnv_scale, gene_anno)
    } else {
      stop(sprintf("[E::%s] unknown method '%s'.", func, method))
    }

    mtx <- rdat$mtx
    overlap <- rdat$overlap

    if (verbose)
      flush_print(sprintf("[I::%s] %d cells and %d genes loaded.",
                     func, nrow(mtx), ncol(mtx)))

    # remove duplicate genes
    genes <- colnames(mtx)
    gene_cnt <- table(genes)
    genes1 <- names(gene_cnt)[as.vector(gene_cnt) == 1]
    mtx <- mtx[, genes1]

    if (verbose)
      flush_print(sprintf(
        "[I::%s] %d cells and %d genes left after removing duplicates.",
        func, nrow(mtx), ncol(mtx)))

    res[[i]] <- list(sid = sid, cnv_type = cnv_type, 
                     method = method, method_sub = method_sub, 
                     mtx_type = mtx_type, 
                     cnv_scale = cnv_scale, mtx = mtx, overlap = overlap)
  }
  return(res)
}


save_extract <- function(dat_list, out_dir, prefix, save_all = FALSE) {
  if (! dir.exists(out_dir))
    dir.create(out_dir, recursive = TRUE)
    
  for (dat in dat_list) {
    mtx <- dat$mtx
    overlap <- dat$overlap
      
    out_fn_mtx <- sprintf(
      "%s/%s.%s.%s.%s.%s_scale.extract.cell_x_gene.mtx.rds", 
      out_dir, dat$sid, dat$cnv_type, dat$method_sub, dat$mtx_type, 
      dat$cnv_scale)
    saveRDS(mtx, out_fn_mtx)
      
    if (! is.null(overlap)) {
      out_fn_overlap <- sprintf(
        "%s/%s.%s.%s.%s.%s_scale.extract.reg2gene_mapping.df.tsv", out_dir,
        dat$sid, dat$cnv_type, dat$method_sub, dat$mtx_type, dat$cnv_scale)
      write_tsv(overlap, out_fn_overlap)
    }
  }
  
  dat_fn <- sprintf("%s/%s.extract.data_list.list.rds", out_dir, prefix)
  saveRDS(dat_list, dat_fn)
}


#' Intersect Cell x Gene Matrices
#' @param dat_list A list of data extracted by calling `run_extract`.
#' @return A list of updated data with intersected matrices.
overlap_mtx_intersect <- function(dat_list) {
  n <- length(dat_list)
  for (i in 1:n) {
    dat <- dat_list[[i]]
    if (i == 1) {
      isec_cell <- rownames(dat$mtx)
      isec_gene <- colnames(dat$mtx)
    } else {
      isec_cell <- base::intersect(isec_cell, rownames(dat$mtx))
      isec_gene <- base::intersect(isec_gene, colnames(dat$mtx))
    }
  }

  new_dat_list <- list()
  for (i in 1:n) {
    dat <- dat_list[[i]]
    dat$mtx <- dat$mtx[isec_cell, isec_gene]
    dat$overlap <- NULL
    new_dat_list[[i]] <- dat
  }
  return(new_dat_list)
}


#' Union Cell x Gene Matrices
#' @inheritParams overlap_mtx_intersect
#' @param na.fill A numeric value to replace NA in the matrix.
#' @return A list of updated data with union matrices.
overlap_mtx_union <- function(dat_list, na.fill = 0.0) {
  n <- length(dat_list)
  for (i in 1:n) {
    dat <- dat_list[[i]]
    if (i == 1) {
      union_cell <- rownames(dat$mtx)
      union_gene <- colnames(dat$mtx)
    } else {
      union_cell <- base::union(union_cell, rownames(dat$mtx))
      union_gene <- base::union(union_gene, colnames(dat$mtx))
    }
  }

  new_dat_list <- list()
  for (i in 1:n) {
    dat <- dat_list[[i]]
    mtx <- matrix(na.fill, nrow = length(union_cell), 
                  ncol = length(union_gene))
    rownames(mtx) <- union_cell
    colnames(mtx) <- union_gene
    cells <- rownames(dat$mtx)
    genes <- colnames(dat$mtx)
    mtx[cells, genes] <- dat$mtx
    dat$mtx <- mtx
    dat$overlap <- NULL
    new_dat_list[[i]] <- dat
  }
  return(new_dat_list)
}


#' Overlap Matrices with Customized Settings
#' @inheritParams overlap_mtx_union
#' @return A list of updated data with overlap matrices.
overlap_mtx_customize <- function(dat_list, na.fill = 0.0) {
  n <- length(dat_list)
  i <- 1
  j <- 1
  for (dat in dat_list) {
    if (i == 1) 
      isec_cell <- rownames(dat$mtx)
    else
      isec_cell <- base::intersect(isec_cell, rownames(dat$mtx))
    i <- i + 1
    if (dat$method == "numbat")
      next     # skip numbat as its matrix only includes target CNV regions.
    if (j == 1)
      isec_gene <- colnames(dat$mtx)
    else
      isec_gene <- base::intersect(isec_gene, colnames(dat$mtx))
    j <- j + 1
  }

  new_dat_list <- list()
  for (i in 1:n) {
    dat <- dat_list[[i]]
    if (dat$method == "numbat") {
      mtx <- matrix(na.fill, nrow = length(isec_cell), 
                    ncol = length(isec_gene))
      rownames(mtx) <- isec_cell
      colnames(mtx) <- isec_gene
      ic <- base::intersect(isec_cell, rownames(dat$mtx))
      ig <- base::intersect(isec_gene, colnames(dat$mtx))
      mtx[ic, ig] <- dat$mtx[ic, ig]
      dat$mtx <- mtx
    } else {
      dat$mtx <- dat$mtx[isec_cell, isec_gene]
    }
    dat$overlap <- NULL
    new_dat_list[[i]] <- dat
  }
  return(new_dat_list)
}


#' Overlap Matrices
#' @inheritParams overlap_mtx_union
#' @param mode A string. Overlap mode, could be `intersect`, `union`,
#'   or `customize`.
#' @param verbose A bool. Whether to output detailed information.
#' @return A list of 3 elements:
#'   cell_overlap, a string vector, overlapped cells.
#'   gene_overlap, a string vector, overlapped genes.
#'   dat_list, a list, updated data with overlap matrices. See 
#'     `run_extract` for details.
run_overlap <- function(dat_list, mode = "intersect", verbose = FALSE) {
  func <- "run_overlap"

  new_dat_list <- NULL
  if (mode == "intersect")
    new_dat_list <- overlap_mtx_intersect(dat_list)
  else if (mode == "union")
    new_dat_list <- overlap_mtx_union(dat_list, na.fill = 0.0)
  else if (mode == "customize")
    new_dat_list <- overlap_mtx_customize(dat_list, na.fill = 0.0)
  else
    stop("[E::%s] unknown mode '%s'.", func, mode)

  if (length(new_dat_list) <= 0)
    stop("[E::%s] updated data list is empty!", func)
    
  mtx <- (new_dat_list[[1]])$mtx
  ovp_cells <- rownames(mtx)
  ovp_genes <- colnames(mtx)

  if (verbose)
    flush_print(sprintf("[I::%s] shape of overlap matrix: (%d, %d)", func, 
                  length(ovp_cells), length(ovp_genes)))
  
  return(list(
    cell_overlap = ovp_cells,
    gene_overlap = ovp_genes,
    dat_list = new_dat_list))
}


save_overlap <- function(res_all, out_dir, prefix, save_all = FALSE) {
  if (! dir.exists(out_dir))
    dir.create(out_dir, recursive = TRUE)
    
  dat_list <- res_all$dat_list
  if (length(dat_list) <= 0)
      return()
  dat <- dat_list[[1]]
    
  cell_overlap_fn <- sprintf("%s/%s.%s.%s_scale.overlap.cells.vec.tsv",
    out_dir, dat$sid, dat$cnv_type, dat$cnv_scale)
  write(res_all$cell_overlap, cell_overlap_fn, sep = "\t")
    
  gene_overlap_fn <- sprintf("%s/%s.%s.%s_scale.overlap.genes.vec.tsv",
    out_dir, dat$sid, dat$cnv_type, dat$cnv_scale)
  write(res_all$gene_overlap, gene_overlap_fn, sep = "\t")

  if (save_all) {
    for (dat in dat_list) {
      mtx <- dat$mtx
      out_fn_mtx <- sprintf(
        "%s/%s.%s.%s.%s.%s_scale.overlap.cell_x_gene.mtx.rds", 
        out_dir, dat$sid, dat$cnv_type, dat$method_sub, dat$mtx_type, 
        dat$cnv_scale)
      saveRDS(mtx, out_fn_mtx)
    }
  }

  dat_fn <- sprintf("%s/%s.overlap.data_list.list.rds", out_dir, prefix)
  saveRDS(dat_list, dat_fn)
}


#' Annotate Cells
#' @param cells A string vector. Cell barcodes.
#' @param annotation A dataframe containing 2 columns: cell <str>, cell_type
#'   <str> cell type.
#' @param verbose A bool. Whether to output detailed information.
#' @return A list of 2 elements:
#'   cell_anno_valied, a dataframe containing 2 columns: cell <str>, 
#'     cell_type <str>, only for annotated cells.
#'   cell_anno_na, a dataframe containing 2 columns: cell <str>, 
#'     cell_type <str>, only for unannotated cells.
run_annotate_cell <- function(cells, annotation, verbose = FALSE) {
  func <- "run_annotate_cell"
    
  cells <- data.frame(cell = cells, stringsAsFactors = FALSE)

  cell_anno <- cells %>%
    dplyr::left_join(annotation, by = "cell")

  cell_anno_valid <- cell_anno %>%
    dplyr::filter(! is.na(cell_type))

  cell_anno_na <- cell_anno %>%
    dplyr::filter(is.na(cell_type))

  if (verbose) {
    if (nrow(cell_anno_na) > 0)
      flush_print(sprintf("[W::%s] %d cells unannotated!", func, 
                          nrow(cell_anno_na)))
    else
      flush_print(sprintf("[I::%s] all %d cells annotated.", func, 
                          nrow(cell_anno)))
  }

  return(list(
    cell_anno_valid = cell_anno_valid,
    cell_anno_na = cell_anno_na
  ))
}


#' Annotate Genes
#' @param genes A string vector. Gene name.
#' @param annotation A dataframe containing 4 columns: Gene <str>, Chr <str>,
#'   start <int>, end <int>.
#' @param verbose A bool. Whether to output detailed information.
#' @return A list of 2 elements:
#'   gene_anno_valied, a dataframe containing 4 columns: Gene <str>, 
#'     Chr <str>, start <int>, end <int>, only for annotated genes.
#'   gene_anno_na, a dataframe containing 4 columns: Gene <str>, 
#'     Chr <str>, start <int>, end <int>, only for unannotated genes.
run_annotate_gene <- function(genes, annotation, verbose = FALSE) {
  func <- "run_annotate_gene"

  genes <- data.frame(Gene = genes, stringsAsFactors = FALSE)
    
  gene_anno <- genes %>%
    dplyr::left_join(annotation, by = "Gene")

  gene_anno_valid <- gene_anno %>%
    dplyr::filter(! is.na(Chr))

  gene_anno_na <- gene_anno %>%
    dplyr::filter(is.na(Chr))

  if (verbose) {
    if (nrow(gene_anno_na) > 0)
      flush_print(sprintf("[W::%s] %d genes unannotated!", func, 
                          nrow(gene_anno_na)))
    else
      flush_print(sprintf("[I::%s] all %d genes annotated.", func, 
                          nrow(gene_anno)))
  }

  return(list(
    gene_anno_valid = gene_anno_valid,
    gene_anno_na = gene_anno_na
  ))
}


save_annotate <- function(cell_annotate, gene_annotate, out_dir, prefix,
                          save_all = FALSE) {
  if (! dir.exists(out_dir))
    dir.create(out_dir, recursive = TRUE)
    
  cell_fn_valid <- sprintf("%s/%s.annotate.valid_cells.df.tsv",
    out_dir, prefix)
  write_tsv(cell_annotate$cell_anno_valid, cell_fn_valid)
    
  cell_fn_na <- sprintf("%s/%s.annotate.na_cells.df.tsv",
    out_dir, prefix)
  write_tsv(cell_annotate$cell_anno_na, cell_fn_na)
    
  gene_fn_valid <- sprintf("%s/%s.annotate.valid_genes.df.tsv",
    out_dir, prefix)
  write_tsv(gene_annotate$gene_anno_valid, gene_fn_valid)
    
  gene_fn_na <- sprintf("%s/%s.annotate.na_genes.df.tsv",
    out_dir, prefix)
  write_tsv(gene_annotate$gene_anno_na, gene_fn_na)
}


#' Subset Data
#' @param cells A string vector. Cell barcodes.
#' @param genes A string vecotr. Gene names.
#' @param dat_list A list of matrix data with overlap cells and genes.
#'   See `run_overlap` for details.
#' @return A list of updated data with subset matrices.
run_subset <- function(cells, genes, dat_list) {
  new_dat_list <- list()
  i <- 1
  for (dat in dat_list) {
    dat$mtx <- (dat$mtx)[cells, genes]
    new_dat_list[[i]] <- dat
    i <- i + 1
  }
  return(new_dat_list)
}


#' @param cells A dataframe containing 2 columns: cell and cell_type.
#'   Typically `cell_anno_valid` returned by `run_annotate_cell`,
#'   with or without filtering.
#' @param genes a dataframe containing 4 columns: Gene, Chr, start, end.
#'   Typically `gene_anno_valid` returned by `run_annotate_gene`,
#'   with or without filtering.
#' @param dat_list A list of updated data with subset matrices, returned
#'   by `run_subset`.
save_subset <- function(cells, genes, dat_list, out_dir, prefix, 
                        save_all = FALSE) {
  if (! dir.exists(out_dir))
    dir.create(out_dir, recursive = TRUE)

  if (length(dat_list) <= 0)
      return()
  dat <- dat_list[[1]]

  cell_fn <- sprintf("%s/%s.%s.%s_scale.subset.cells.df.tsv",
    out_dir, dat$sid, dat$cnv_type, dat$cnv_scale)
  write_tsv(cells, cell_fn)
    
  gene_fn <- sprintf("%s/%s.%s.%s_scale.subset.genes.df.tsv",
    out_dir, dat$sid, dat$cnv_type, dat$cnv_scale)
  write_tsv(genes, gene_fn)
    
  if (save_all) {
    for (dat in dat_list) {
      mtx <- dat$mtx
      mtx_fn <- sprintf(
        "%s/%s.%s.%s.%s.%s_scale.subset.cell_x_gene.mtx.rds", 
        out_dir, dat$sid, dat$cnv_type, dat$method_sub, dat$mtx_type, 
        dat$cnv_scale)
      saveRDS(mtx, mtx_fn)
    }
  }

  dat_fn <- sprintf("%s/%s.subset.data_list.list.rds", out_dir, prefix)
  saveRDS(dat_list, dat_fn)
}


#' Construct Ground Truth Matrix
#' @param cells A dataframe containing 2 columns: cell and cell_type.
#'   Typically `cell_anno_valid` returned by `run_annotate_cell`,
#'   with or without filtering.
#' @param genes a dataframe containing 4 columns: Gene, Chr, start, end.
#'   Typically `gene_anno_valid` returned by `run_annotate_gene`,
#'   with or without filtering.
#' @param truth A dataframe containing 5 columns: chrom, start, end, 
#'   cnv_type, and cell_type.
#' @param cnv_type A string. CNV type, could be `copy_gain`, `copy_loss`,
#'   or `loh`.
#' @param verbose A bool. Whether to output detailed information.
#' @return A list of 2 elements:
#'   gene_overlap, a dataframe containing 2 columns: Gene, <str>, gene name;
#'     reg_id, <str> ID of overlapping region(s).
#'   truth_mtx, a cell x gene binary matrix of CNV ground truth.
run_truth <- function(cells, genes, truth, cnv_type, verbose = FALSE)
{
  func <- "run_truth"

  cnv_type0 <- cnv_type
  truth <- truth %>%
    dplyr::filter(cnv_type == cnv_type0) %>%
    dplyr::mutate(chrom = stringr::str_remove(chrom, "chr")) %>%
    dplyr::mutate(reg_id = sprintf("%s:%s-%s", chrom, start, end))

  if (verbose) {
    flush_print(sprintf("[I::%s] the CNV ground truth is:", func))
    str(truth)
  }

  regions <- truth %>%
    dplyr::select(reg_id, chrom, start, end) %>%
    dplyr::distinct(reg_id, .keep_all = TRUE) 

  res <- overlap_gene_anno(regions, genes)
  gene_overlap <- res$gene_overlap
  n_dup <- res$n_dup
  gene_uniq <- res$gene_uniq

  if (verbose) {
    if (n_dup > 0) {
      flush_print(sprintf("[W::%s] %d genes overlap with >1 cnv regions!", 
                    func, n_dup))
    }
    flush_print(sprintf("[I::%s] %d genes overlap with 1 cnv region.", 
          func, nrow(gene_uniq)))   
  }

  truth_gene <- gene_overlap %>%       # <Gene> <reg_id> 
    dplyr::left_join(truth %>% dplyr::select(reg_id, cell_type), 
                     by = "reg_id") %>%    # <Gene> <reg_id> <cell_type>
    dplyr::select(Gene, cell_type) %>%     # <Gene> <cell_type>
    dplyr::distinct(Gene, cell_type) %>%
    dplyr::left_join(cells, by = "cell_type") %>%  # <Gene> <cell_type> <cell>
    dplyr::select(Gene, cell) %>%
    dplyr::distinct(Gene, cell)

  if (verbose) {
    flush_print(sprintf("[I::%s] ground truth matrix mapping to gene scale:", 
                        func))
    str(truth_gene)
  }

  truth_gene1 <- truth_gene %>%
    dplyr::mutate(value = 1) %>%
    tidyr::spread(Gene, value, fill = 0)

  truth_gene1 <- as.data.frame(truth_gene1)
  rownames(truth_gene1) <- truth_gene1$cell
  truth_gene1 <- as.matrix(truth_gene1[, -1])

  if (verbose) {
    flush_print(sprintf("[I::%s] cell x gene matrix in CNV state:", func))
    str(truth_gene1)
  }

  mtx <- matrix(0, nrow = nrow(cells), ncol = nrow(genes))
  rownames(mtx) <- cells$cell
  colnames(mtx) <- genes$Gene
  mtx[rownames(truth_gene1), colnames(truth_gene1)] <- truth_gene1

  if (verbose) {
    flush_print(sprintf("[I::%s] dim of binary truth matrix:", func))
    flush_print(dim(mtx))
  }

  return(list(
    gene_overlap = gene_overlap,
    truth_mtx = mtx
  ))
}


save_truth <- function(res, out_dir, prefix, save_all = FALSE) {
  if (! dir.exists(out_dir))
    dir.create(out_dir, recursive = TRUE)

  gene_overlap <- res$gene_overlap
  truth_mtx <- res$truth_mtx

  gene_overlap_fn <- sprintf("%s/%s.truth.reg2gene_mapping.df.tsv",
    out_dir, prefix)
  write_tsv(gene_overlap, gene_overlap_fn)
    
  mtx_fn <- sprintf("%s/%s.truth.cell_x_gene.binary.mtx.rds",
    out_dir, prefix)
  saveRDS(truth_mtx, mtx_fn)
}


run_roc <- function(dat_list, truth_mtx, max_n_cutoff = 1000, strict = TRUE, 
                    verbose = FALSE) 
{
  func <- "run_roc"
  if (verbose)
    flush_print(sprintf("[I::%s] begin ...", func))

  res <- run_metric(metric = "ROC", dat_list = dat_list, 
                    truth_mtx = truth_mtx, max_n_cutoff = max_n_cutoff,
                    strict = stric, verbose = verbose)
  return(res)
}


save_roc <- function(dat_list, out_dir, prefix, save_all = FALSE,
                     verbose = FALSE) {
  func <- "save_roc"
  if (verbose)
    flush_print(sprintf("[I::%s] begin ...", func))

  res <- save_metric(metric = "ROC", dat_list = dat_list, 
                     out_dir = out_dir, prefix = prefix, 
                     save_all = save_all)
  return(res)
}


plot_roc <- function(
  dat_list, dec = 3, title = NULL,
  legend_xmin = 0.7, legend_ymin = 0.25, method_sub_case = "canonical") 
{
  func <- "plot_roc"
  res <- run_plot(metric = "ROC",
                  dat_list = dat_list, dec = dec, title = title,
                  legend_xmin = legend_xmin, legend_ymin = legend_ymin,
                  method_sub_case = method_sub_case)
  return(res)
}


run_prc <- function(dat_list, truth_mtx, max_n_cutoff = 1000, strict = TRUE, 
                    verbose = FALSE) 
{
  func <- "run_prc"
  if (verbose)
    flush_print(sprintf("[I::%s] begin ...", func))

  res <- run_metric(metric = "PRC", dat_list = dat_list, 
                    truth_mtx = truth_mtx, max_n_cutoff = max_n_cutoff,
                    strict = stric, verbose = verbose)
  return(res)
}


save_prc <- function(dat_list, out_dir, prefix, save_all = FALSE,
                     verbose = FALSE) {
  func <- "save_prc"
  if (verbose)
    flush_print(sprintf("[I::%s] begin ...", func))

  res <- save_metric(metric = "PRC", dat_list = dat_list, 
                     out_dir = out_dir, prefix = prefix, 
                     save_all = save_all)
  return(res)
}


plot_prc <- function(
  dat_list, dec = 3, title = NULL,
  legend_xmin = 0.7, legend_ymin = 0.25, method_sub_case = "canonical") 
{
  func <- "plot_prc"
  res <- run_plot(metric = "PRC",
                  dat_list = dat_list, dec = dec, title = title,
                  legend_xmin = legend_xmin, legend_ymin = legend_ymin,
                  method_sub_case = method_sub_case)
  return(res)
}


#' Calculate Metrics
#' @param metric A string indicating metric, "ROC" or "PRC".
#' @param dat_list A list of CNV baf/expr/prob data for each method, see 
#'   `run_overlap` or `run_subset` for details.
#' @param truth_mtx A cell x gene binary matrix of CNV ground truth, see
#'   `run_truth` for details.
#' @param max_n_cutoff An integer. Maximum number of sampled cutoff values.
#' @param strict A bool. Whether to raise error when cell or genes in truth
#'   and method matrices are different. 
#' @param verbose A bool. Whether to output detailed information.
#' @return A list of updated CNV baf/expr/prob data.
run_metric <- function(metric, dat_list, truth_mtx, max_n_cutoff = 1000, 
                       strict = TRUE, verbose = FALSE) 
{
  func <- "run_metric"

  metric_upper <- stringr::str_to_upper(metric)
  metric_lower <- stringr::str_to_lower(metric)

  truth_cells <- rownames(truth_mtx)
  truth_genes <- colnames(truth_mtx)

  new_dat_list <- list()

  set.seed(123)

  for (i in 1:length(dat_list)) {
    dat <- dat_list[[i]]
    mtx <- dat$mtx
    cells <- rownames(mtx)
    genes <- colnames(mtx)
    dat_id <- sprintf("%s-%s", dat$method_sub, dat$mtx_type)

    if (verbose)
      flush_print(sprintf("[I::%s] begin to process %s.", func, dat_id))

    if (length(truth_cells) != length(cells)) {
      if (strict)
        stop(sprintf("[E::%s] #cells in truth and %s matrix: %d, %d",
                     func, dat_id, length(truth_cells), length(cells)))
      flush_print(sprintf("[I::%s] #cells in truth and %s matrix: %d, %d",
                    func, dat_id, length(truth_cells), length(cells)))
      if (! all(truth_cells %in% cells))
        stop(sprintf("[E::%s] some truth-cells are not in %s matrix!", 
                     func, dat_id))
      mtx <- mtx[truth_cells, ]
      cells <- rownames(mtx)
    }

    if (! all(sort(truth_cells) == sort(cells))) {
      stop(sprintf(
        "[E::%s] some cells in truth and %s matrix are different!", 
          func, dat_id))
    }

    if (length(truth_genes) != length(genes)) {
      if (strict)
        stop(sprintf("[E::%s] #genes in truth and %s matrix: %d, %d",
                     func, dat_id, length(truth_genes), length(genes)))
      flush_print(sprintf("[I::%s] #genes in truth and %s matrix: %d, %d",
                    func, dat_id, length(truth_genes), length(genes)))
      if (! all(truth_genes %in% genes))
        stop(sprintf("[E::%s] some truth-genes are not in %s matrix!", 
                     func, dat_id))
      mtx <- mtx[, truth_genes]
      genes <- colnames(mtx)
    }

    if (! all(sort(truth_genes) == sort(genes))) {
      stop(sprintf(
        "[E::%s] some genes in truth and %s matrix are different!", 
          func, dat_id))
    }

    if (dat$mtx_type == "expr" && dat$cnv_type == "copy_loss") {
      mtx <- mtx * (-1)
    }

    # keep the order of cell & gene the same with ground truth matrix
    mtx <- mtx[truth_cells, truth_genes]

    if (verbose) {
      flush_print(sprintf("[I::%s] dim of final %s matrix:", func, dat_id))
      flush_print(dim(mtx))
    }

    mt_obj <- NULL
    cutoff <- base::sort(base::unique(c(mtx)))
    if (length(cutoff) > max_n_cutoff)
      cutoff <- sample(cutoff, size = max_n_cutoff)
    cutoff <- sort(base::unique(c(cutoff, 0, 1)))
    if (metric_upper == "ROC")
      mt_obj <- cardelino::binaryROC(mtx, truth_mtx, cutoff = cutoff)
    else
      mt_obj <- cardelino::binaryPRC(mtx, truth_mtx, cutoff = cutoff, 
                                     add_cut1 = TRUE)
      
    if (verbose) {
      flush_print(sprintf("[I::%s] AUC = %f.", func, mt_obj$AUC))
    }

    dat$mtx <- mtx
    dat[[metric_lower]] <- mt_obj
    dat$auc <- mt_obj$AUC
    new_dat_list[[i]] <- dat
  }

  return(new_dat_list)
}


save_metric <- function(metric, dat_list, out_dir, prefix, save_all = FALSE) {
  if (! dir.exists(out_dir))
    dir.create(out_dir, recursive = TRUE)

  metric_upper <- stringr::str_to_upper(metric)
  metric_lower <- stringr::str_to_lower(metric)

  auc <- data.frame(
    method = sapply(dat_list, "[[", "method"),
    method_sub = sapply(dat_list, "[[", "method_sub"),
    mtx_type = sapply(dat_list, "[[", "mtx_type"),
    auc = sapply(dat_list, "[[", "auc"),
    stringsAsFactors = FALSE
  )
  auc_fn <- sprintf("%s/%s.%s.auc.df.tsv", out_dir, prefix, metric_lower)
  write_tsv(auc, auc_fn)
    
  i <- 1
  for (dat in dat_list) {
    mtx_fn <- sprintf("%s/%s.%s.%s.%s.%s_scale.%s.cell_x_gene.mtx.rds", 
      out_dir, dat$sid, dat$cnv_type, dat$method_sub, dat$mtx_type, 
      dat$cnv_scale, metric_lower)
    if (save_all && ! is.null(dat$mtx))
      saveRDS(dat$mtx, mtx_fn)

    metric_fn <- sprintf("%s/%s.%s.%s.%s.%s_scale.%s.cardelino_cutoff.%s.rds", 
      out_dir, dat$sid, dat$cnv_type, dat$method_sub, dat$mtx_type, 
      dat$cnv_scale, metric_lower, metric_lower)
    saveRDS(dat[[metric_lower]], metric_fn)

    i <- i + 1
  }

  dat_fn <- sprintf("%s/%s.%s.pre_plot_dat_list.list.rds", out_dir, prefix,
                    metric_lower)
  saveRDS(dat_list, dat_fn)
}


format_method_sub <- function(method_sub, method_sub_case) {
  func <- "format_method_sub"

  if (method_sub_case == "canonical") {
    name_dict <- list(
      casper = "CaSpER",
      casper_median = "CaSpER_median",
      casper_mediandev = "CaSpER_medianDev",
      copykat = "CopyKAT",
      infercnv = "InferCNV",
      numbat = "Numbat",
      xclone = "XClone"
    )
    s_str <- stringr::str_to_lower(method_sub)
    if (! s_str %in% names(name_dict))
      stop(sprintf("[E::%s] unknown method_sub '%s'.", func, method_sub))
    t_str <- name_dict[[s_str]]
    return(t_str)
  } else if (method_sub_case == "lower") {
    name_dict <- list(
      casper = "casper",
      casper_median = "casper_median",
      casper_mediandev = "casper_medianDev",
      copykat = "copykat",
      infercnv = "infercnv",
      numbat = "numbat",
      xclone = "xclone"
    )
    s_str <- stringr::str_to_lower(method_sub)
    if (! s_str %in% names(name_dict))
      stop(sprintf("[E::%s] unknown method_sub '%s'.", func, method_sub))
    t_str <- name_dict[[s_str]]
    return(t_str)
  } else if (method_sub_case == "raw") {
    return(method_sub)
  } else {
    stop(sprintf("[E::%s] unknown case type '%s'.", func, method_sub_case))
  }
}


#' Plot Metric
#' @param metric A string indicating metirc, "ROC" or "PRC".
#' @param dat_list A list of CNV baf/expr/prob data for each method, 
#'   returned by `run_metric`.
#' @param dec An integer. Number of decimal places for AUC.
#' @param title A string. Title of figure.
#' @param legend_xmin A float. The xmin position of legend.
#' @param legend_ymin A float. The ymin position of legend.
#' @param method_sub_case A string. Type of string case of `method_sub`, could
#'   be `raw` (no change), `lower`, `canonical`.
#' @return A ggplot2 object.
run_plot <- function(
  metric, dat_list, dec = 3, title = NULL,
  legend_xmin = 0.7, legend_ymin = 0.25, method_sub_case = "canonical") 
{
  func <- "run_plot"

  metric_upper <- stringr::str_to_upper(metric)
  metric_lower <- stringr::str_to_lower(metric)

  p_data <- NULL
  for (dat in dat_list) {
    method_sub <- format_method_sub(dat$method_sub, method_sub_case)
    mt_obj <- dat[[metric_lower]]
    d <- mt_obj$df
    if (dec == 4)
      d$method <- sprintf("%s: AUC=%.4f", method_sub, mt_obj$AUC)
    else
      d$method <- sprintf("%s: AUC=%.3f", method_sub, mt_obj$AUC)
    p_data <- base::rbind(p_data, d)
  }

  p <- NULL
  if (metric_upper == "ROC")
    p <- ggplot2::ggplot() +
      ggplot2::geom_line(
        data = p_data,
        ggplot2::aes(x = FPR, y = TPR, color = method, group = method),
        size = .3) +
      ggplot2::labs(
        x = "False Positive Rate (1 - Specificity)", 
        y = "True Positive Rate (Sensitivity)", 
        title = title,
        color = NULL)
  else
    p <- ggplot2::ggplot() +
      ggplot2::geom_line(
        data = p_data,
        ggplot2::aes(x = Recall, y = Precision, color = method, group = method),
        size = .3) +
      ggplot2::labs(
        x = "Recall", 
        y = "Precision", 
        title = title,
        color = NULL)

  p <- p +
    ggplot2::scale_x_continuous(breaks = c(0, .2, .4, .6, .8, 1)) +
    ggplot2::scale_y_continuous(breaks = c(0, .2, .4, .6, .8, 1)) +
    ggplot2::theme_bw() +
    ggplot2::theme(
      panel.grid.major = ggplot2::element_blank(),
      panel.grid.minor = ggplot2::element_blank(),
      panel.background = ggplot2::element_blank(),
      panel.border = ggplot2::element_blank()) +
    ggplot2::theme(
      plot.title = ggplot2::element_text(size = 7, hjust = .5, face = "bold"),
      axis.title = ggplot2::element_text(size = 6),
      axis.text = ggplot2::element_text(size = 4),
      axis.line = ggplot2::element_line(size = .3),
      axis.ticks = ggplot2::element_line(size = .3)) +
    ggplot2::theme(
      legend.key.size = ggplot2::unit(.5, "cm"),
      legend.key = ggplot2::element_rect(
        color = "transparent", fill = "transparent"),
      legend.key.height = ggplot2::unit(.25, "cm"),
      legend.position = c(legend_xmin, legend_ymin),
      legend.text = ggplot2::element_text(size = 5),
      legend.background = ggplot2::element_rect(
        color = "transparent", fill = "transparent"))

  return(p)
}

